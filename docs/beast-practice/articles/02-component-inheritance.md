# Наследование компонентов

Наследование в Beast — расширение одной декларации другими. Это позволяет как строить новые компоненты на базе существующих, так и выносить за скобку общий код (в так называемые абстрактные компоненты).

## Новые компоненты на базе существующих

Для примера рассмотрим блок `Snippet`.

```xml
<Snippet>
    <title>...</title>
    <url>...</url>
    <text>...</text>
</Snippet>
```

```js
Beast.decl({
    Snippet: {
        mod: {
            ShowFavicon: false,
        },
        expand: function () {
            this.append(
                this.get('title', 'url', 'text')
            )
        }
    },
})
```

Со временем этот блок потребуется усложнить: добавить бейджик «реклама», сайтлинки, метаданные, рейтинг, карусель картинок, таблицу и так далее; позже обнаружится, что в одном случае удобно иметь таблицу над каруселью картинок, а в другом — под. Блок будет становиться сложным как сточки зрения польвазотеля (из-за перегруженной логики входых данных) так и с точки зрения разработки (кода будет все больше и больше, сложность внесения изменений растет экспоненциально). Таким образом, подобные конструкции надо разгружать.

Блок снипет следует ограничить самыми общими полями, а дальше начать отпускать потомков. Например, колдунщик картинок станет самостоятельным блоком, расширяющим блок снипета.

```xml
<SnippetImages>
    <title>...</title>
    <url>...</url>
    <images>
        <image>...</image>
        <image>...</image>
        ...
    </images>
</SnippetImages>
```

```js
Beast.decl({
    SnippetImages: {
        inherits:'Snippet',
        mod: {
            Size:'M'
        },
        expand: function fn () {
            this.inherited(fn)
                .append(
                    this.get('images')
                )
        }
    },
    SnippetImages__title: {
        inherits:'Snippet__title'
    },
    SnippetImages__url: {
        inherits:'Snippet__url'
    }
})
```

Важно отметить, что наследование происходит именно на уровне компонентов, а не только блоков. Поэтому в примере с `SnippetImage` подтребовалось наследовать не только блок, но и элементы от соотствующих элементов `Snippet`. Сделано это для большей гибкости: с одной стороны, наследовать можно лишь то, что нужно для задачи, с другой, элемент может наследоваться от другого блока (например, `Snippet__button` от `Button`).

Как работает наследование: оно расширяет деларацию потомка полями декларации предка. Поэтому декларация `SnippetImages` становится фактически такой:

```js
Beast.decl({
    SnippetImages: {
        mod: {
            Size:'M',
            ShowFavicon: false,
        },
        expand: function () {
            this.append(
                this.get('title', 'url', 'text')
            )

            this.append(
                this.get('images')
            )
        }
    }
})
```

Важно при этом не забывать про метод `inherited()`, который и обеспечил в примере правильную склейку кода функции `expand` для `SnippetImages` и `Snippet`.

Наследуется не только декларация, но и CSS — за счет вывода CSS-классов с модификаторами как для текущего компонента, так и для предка. HTML для `SnippetImages` будет таким:

```xml
<div class="snippetimages snippet snippetimages_size_m snippet_size_m">
    <div class="snippetimages__title snippet__title">...</div>
    <div class="snippetimages__url snippet__url">...</div>
    <div class="snippetimages__images">
        <div class="snippetimages__image">...</div>
        <div class="snippetimages__image">...</div>
        ...
    </div>
</div>
```

В итоге дерево наследования компонентов на базе снипета может получиться таким:
```
snippet
    snippetImages
    snippetVideo
    snippetMusic
        snippetMusicAlbum
        snippetMusicArtist
        snippetMusicTrack
```

Так при создании очередного компонента в этой предметной области потребуется описать лишь его поведение, дополняющее `Snippet`, не копируя внутрь код самого `Snippet`. А изменения в родительком компоненте автоматически коснутся детей — `Snippet` может сколько угодно менять размер заголовка, цвет текста и пр.

## Абстрактные компоненты

Это компоненты, которые не отображаются в интерфейсе, но содержат общие для потомков поведение. Включаются полем декларации `abstract:true`. Имя такого компонента не будет фигурировать в CSS-классе потомков — другими словами, за абстрктными компонентами не может быть закреплено никакого внешнего вида.

Разберем пример, где такое было бы оправдано — контролы. Абстрактный компонент `Control` включит в себя:
- Модификаторы размера, темы и состояний
- Реакцию на браузерные события, меняющие модификаторы компонента
- Пользовательские события
- Общие стили: соответствующая модификатору size высота, внешний вид фокуса и пр.

```js
Beast.decl({
    Control: {
        abstract:true,
        mod: {
            Focus: false,
            State: 'release',
            Theme: 'default',
        },
        on: {
            'mousedown touchstart': function(e) {
                ...
            },
            'mouseup touchend': function(e) {
                ...
            },
            'mouseout touchmove': function() {
                ...
            },

            Press: '',
            Release: '',
            Focus: '',
            Blur: '',
            MouseOver: '',
            MouseOut: '',
        }
    }
})
```

Потомок `Button` лишь добавит отображение иконки и пару модификаторов внешнего вида. Блок `Input` чуть больше расширит `Control`, но все равно — код блока сфокусируется именно на особенностях поведения инпута, не отвлекаясь больше на отработку браузерных событий.

```js
Beast.decl({
    Input: {
        inherits:'Control',
        mod: {
            Size:'M'
        },
        expand: function fn () {
            this.inherited(fn)
                .append(
                    <input/>,
                    <clear/>
                )
        },
        value: function (value) {
            if (typeof value === 'undefined') {
                return this.elem('input')[0].domNode().value
            } else {
                this.elem('input')[0].domNode().value = value
            }
        },
        focus: function () {
            this.elem('input')[0].domNode().focus()
        },
        blur: function () {
            this.elem('input')[0].domNode().blur()
        },
    },
    input__input: {
        tag:'input',
        on: {
            focus: function() {
                this.parentBlock().mod('Focus', true)
            },
            blur: function() {
                this.parentBlock().mod('Focus', false)
            },
        }
    },
    Input__clear: {
        on: {
            click: function () {
                this.parentBlock().value('')
            }
        }
    }
})
```

В будущем любой активный элемент, например, плашка «Показать ещё» в каком-нибудь списке, сможет наследоваться от control и добавить свою реакцию на нажатие и свой внешний вид; при этом автоматически будут учтены все тонкости поведения активного элемента. Так, благодаря наследованию, помимо сокращения времени разработки и фокусировке только на уникальных особенностях текущего компонента, однородные компоненты получают консистентные правила поведения.

## Множественное наследование

Благодаря этому механизму можно складывать в компонент, как в корзину, функциональность других компонентов. Например, блок `Grid` содержит поведение сетки, а блок `Control` — поведение активного элемента. Блоку `Button` пригодится поведение обоих: во-первых, это активный элемент, а во-вторых, ему полезно уметь подчиняться колонкам сетки для построения аккуратных веб-форм.

```js
Beast.decl({
    Button: {
        inherits:['Control', 'Grid']
    }
})
```

Кнопка размера М шириной в три колонки:

```xml
<Button Size="M" Col="3">Найти</Button>
```
