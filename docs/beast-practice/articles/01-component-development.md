# Разработка компонента

## Оптимальное именование

В именах любых сущностей: блоков, элементов, модификаторов, событий и параметров — следует использовать нотацию __camelCase__ — это избавляет от необходимости писать кавычки в json. Названия блоков пишутся с большой буквы.

__Неправильно:__
```js
Beast.decl({
    'block-name': {
        ...
    },
    'block-name__element-name'
})
```

__Правильно:__
```js
Beast.decl({
    BlockName: {
        ...
    },
    BlockName__elementName: {
        ...
    }
})
```

__Составные имена__ используются для однородных компонентов (как правило, они имеют общего предка). Представим некий блок карточки `Card` с фоном и заголовком. От этого блока может наследоваться карточка с формой заказа такси — логично назвать ее `CardTaxi`; карточка поиска для авиабилетов — `CardAvia`, и так далее.

Если блоки сильно разнятся между собой по внешнему виду и поведению, но имеют общего предка — не стоит учитывать это в их именах. Например `Button` и `Input` могут быть унаследованы от `Control`, но названия `ControlButton` и `ControlInput` были бы избыточны. 

Составные имена дают элементам, когда те подчинены другим элементам.

```xml
<Head>
    <menu>
        <menuItem>...</menuItem>
        <menuItem>...</menuItem>
    </menu>
    <submenu>
        <submenuItem>...</submenuItem>
        <submenuItem>...</submenuItem>
    </submenu>
<Head>
```

## Работа с модификаторами

Модификаторы определяют характеристики внешнего вида и поведения компонента. Изменение модификатора порождает соответствующее событие. Модификатору соответствует CSS-класс. Модификаторы пишутся с большой буквы.

__Модификатор состояния__ компонента (State) встречается чаще остальных. Существует соглашение, что если значение модификатора — глагол, то совершенного вида: actived, closed, selected.

Общепринятые названия и значения (в скобках) частоиспользуемых модификаторов:
- __State__ (released, activated) — состояние
- __Theme__ (default) — скин внешнего вида
- __Size__ (XS, S, M, L, XL) — размер
- __Col__ — ширина в колонках сетки

В декларации компонента следует перечислять все возможные модификаторы со значениями по умолчанию, а также перечислением возможных значений в комментариях (то же касается и параметров).

```js
Beast.decl({
    Button: {
        mod: {
            Size: 'M', // S, M, L
            Theme: 'light', // light, dark
            Style: 'fill', // fill, border
        },
        param: {
            width: '',
            height: '',
            href: '',
        }
    }
})
```

## Работа параметрами

Параметры хранят абстрактные значения, которые могут быть использованы для чего угодно. Изменение параметра не сопровождается событием. Параметр никак не отображается в DOM-дереве.

__Параметр или модификатор?__ Параметры следует использовать везде, где не требуются особенности модификатора.

__Параметр или элемент?__ В элементами выражатеся то, что в итоге будет отображено. Параметры лишь влияют на поведение или отображение.

__Неправильно:__
```xml
<Contents>
    <title>Содержание</titlte>
    <group title="Глава I">
        <item>...</item>
        <item>...</item>
    </group>
</Contents>

<Button>
    <width>200</width>
</Button>
```

__Правильно:__
```xml
<Contents>
    <title>Содержание</titlte>
    <group>
        <groupTitle>Глава I</groupTitle>
        <item>...</item>
        <item>...</item>
    </group>
</Contents>

<Button width="200">...</Button>
```

Бывают менее однозначные ситуации: например, в блоке цены нужно указать код валюты, но на вывод попадет символ, а не код. В таких случаях предпочтение следует отдавать элементу.

__Неправильно:__
```xml
<Price code="RUB">10000</Price>
```

__Правильно:__
```xml
<Price>
    <value>10000</value>
    <code>RUB</code>
</Price>
```

## Работа с пользовательскими методами

Методы могут быть private (для внутренних нужд, имя начинается с `_`) и public (интерфейс компонента). Элементы не следует наделять public-методами.

```js
Beast.decl({
    Input: {
        focus: function () {
            this.elem('input').domNode().focus()
        },
        _hidePlaceholder: () {
            this.elem('placeholder').mod('State', 'release')
        }
    }
})
```

## Работа с пользовательскими событиями

События компонент являются стандартными DOM-событиями. Чтобы застраховаться от пересечения имен с событиями браузера, внутренние события следует называть с большой буквы. Поддерживаемые компонентом события следует перечислять в поле декларации `on` с пустой строкой в качестве значения.

```js
Beast.decl({
    Control: {
        on: {
            click: function () {
                this.trigger('Release')
            },

            Press: '',
            Release: '',
            Focus: '',
            Blur: '',
        }
    }
})
```

События сообщают наружу об изменениях в компоненте. Не следует использовать события для внутренних манипуляций — для этого есть пользовательские методы.

__Неправильно:__
```js
Beast.decl({
    Message: {
        on: {
            Close: function () {
                this.css('opacity', 0)
                setTimeout(
                    function () {
                        this.mod('State', 'release')
                    }.bind(this),
                    this.param('opacityTransitionTime')
                )
            }
        },
    },
    Message__close: {
        on: {
            click: function () {
                this.trigger('Close')
            }
        }
    }
})
```

__Правильно:__
```js
Beast.decl({
    Message: {
        close: function () {
            this.css('opacity', 0)
            setTimeout(
                function () {
                    this.mod('State', 'release')
                }.bind(this),
                this.param('opacityTransitionTime')
            )
        }
    },
    Message__close: {
        on: {
            click: function () {
                this.parentBlock().close()
            }
        }
    }
})
```

Существует соглашение, что события именуются инфинитивами. Если действие растянуто во времени (например, действие с анимацией), следует уточнить приставками `will` и `did` в какой момент вызывается связанное событие: `DidClose`, `WillClose`.

```js
Beast.decl({
    Message: {
        close: function () {
            this.trigger('WillClose')
            setTimeout(
                function () {
                    ...
                    this.trigger('DidClose')
                }.bind(this),
                1000
            )
        }
    }
})
```

Если в событии замешан элемент, его имя ставится в конец: `ActivateTab`, `DidActivateTab`, `WillActivateTab`.

```js
Beast.decl({
    Menu__tab: {
        onMod: {
            active: function () {
                this.trigger('ActivateTab')
            }
        }
    },
})
```

## Работа с событиями общей шины

События общей шины следует называть с большой буквы, для общности с событиями компонентов.

```js
Beast.decl({
    Arrow: {
        submit: function () {
            ...
            this.triggerWin('Submit', query)
        }
    },
    Serp: {
        on: {
            'Arrow:Submit': function (e, query) {
                this.update(query)
            }
        }
    }
})
```

Этот тип событий — является одним из способов слабого связывания компонент. Если на обычное событие можно подписаться лишь имея ссылку на компонент (что доступно лишь ближайшим родителям), то на событие общей шины может подписываться кто угодно. Более подробно о ситуациях, в которых такой тип событий дает преимущества, рассказывается в главе о [взаимодействии компонент](04-component-interaction.md).

## Строгое API

Если у компонента __фиксированный порядок элементов__, никогда не стоит полагаться на порядок и состав, указанный пользователем; в свою очередь пользователю тоже не придется об этом думать. Кроме того, разработчик блока в любой момент может захотеть поменять порядок следования элементов.

```xml
<Snippet>
    <title>...</title>
    <text>...</text>
    <url>...</url>
</Snippet>
```

__Неправильно:__
```js
Beast.decl({
    Snippet: {
        expand: function () {
            this.append(
                this.get('/')
            )
        }
    }
})
```

__Правильно:__
```js
Beast.decl({
    Snippet: {
        expand: function () {
            this.append(
                this.get('title', 'url', 'text')
            )
        }
    }
})
```

__Модификаторы и параметры__ должны быть интерфейсом блока лишь в контексте BML. Для дальнейшего взаимодействия с компонентом снаружи следует использовать __методы__ — во-первых, потому что методы универсальнее и могут в том числе устанавливать модификаторы, во-вторых, это делает работу с чужими блоками более консистентной и простой, а в-третьих, у компонента уже есть набор стандартных методов, которые уже диктуют модель взаимодействия: `on()`, `append()`, `elem()` и т.д.

__Неправильно:__
```js
var modalWindow = <ModalWindow>...</ModalWindow>
modalWindow
    .mod('Animation', 'zoom-in')
    .mod('State', 'activated')
```

__Правильно:__
```js
var modalWindow = <ModalWindow Animation="zoom-in">...</ModalWindow>
modalWindow.activate()

...

Best.decl({
    ModalWindow: {
        activate: function () {
            this.mod('State', 'activated')
        }
    }
})
```

## Инкапсуляция и полиморфизм

В API блока не должно быть обязательных дочерних компонентов — указыватется лишь то, что может меняться.

__Неправильно:__
```xml
<MessageWindow>
    <text>...</text>
    <close/>
</MessageWindow>
```

__Правильно:__
```xml
<MessageWindow>
    <text>...</text>
</MessageWindow>
```

Если дочерний блок вставляется не как есть, а с ним проводятся дополнительные манипуляции, его следует выразить в API через элемент.

__Неправильно:__
```xml
<Form>
    <fields>...</fields>
    <Button Size="M" Type="submit">...</Button>
</Form>
```

__Правильно:__
```xml
<Form>
    <fields>...</fields>
    <submit>...</submit>
</Form>
```

```js
Beast.decl({
    Form__submit: {
        expand: function () {
            this.implementWith(
                <Button Size="M" Type="submit">{this.text()}</Button>
            )
        }
    }
})
```

В целом, это полезная практика — выражать дочерние блоки через элементы. С одной стороны, пользователю блока не обязательно знать, из чего тот собран; а с другой, дочерние блоки становятся доступны через метод `this.elem('implementedElementName')`, который, в отличие от `this.get('BlockName')`, не обязывает учитывать вложенность, а также позволяет относиться к дочернему блоку как к обычному элементу, что больше фокусирует на текущей работе.

Более подробно об особенностях метода `implementWith` и о его отличии от наследования рассказывается в главе «[Имплементация компонентов](03-component-implementation.md)».

## Для чего нужен &lt;script type="bml"&gt;

BML в HTML-странице должен быть не более, чем деревом данных. Не рекомендуется добавлять дополнительную смысловую нагрузку, так как это делает компоненты зависимыми от конфигурации конкретной страницы.

__Нерпавильно:__
```xml
<html>
    <head>
        <script type="bml">
            <App>
                <Tabs>
                    <tab State="active" rel="bookmarks">Закладки</tab>
                    <tab rel="settings">Настройки</tab>
                </Tabs>
                <Screen id="bookmarks">...</Screen>
                <Screen id="settings">...</Screen>
            </App>
        </script>
    </head>
</html>
```

__Правильно:__
```xml
<html>
    <head>
        <script type="bml">
            <App>
                <Screens>
                    <screen>
                        <title>Закладки</title>
                        ...
                    </screen>
                    <screen>
                        <title>Настройки</title>
                        ...
                    </screen>
                </Screens>
            </App>
        </script>
    </head>
</html>
```

Подробно об организации взаимодействия компонентов рассказывается в [соответствующей главе](04-component-interaction.md).
